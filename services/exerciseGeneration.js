const Exercise = require("../models/Exercise.js");
const Assignment = require("../models/Assignment.js");
const User = require("../models/User.js");
const mongoose = require("mongoose");
const crypto = require("crypto");

const { getSubmission } = require("../utils/studentSubmission.js");
const {
    systemPromptSpecificQuestionCategory,
    userPrompt,
    systemPromptQuestionCategories
} = require("../utils/prompts.js");
const { findAuthor } = require("../utils/exerciseHelpers.js");

const { generateAIResponse } = require("./responseGeneration.js");

const { ObjectId } = mongoose.Types;

/**
 * Generates question categories for an exercise using a system prompt and a student's submission.
 * Calls the AI service to generate categories, with retry logic for failures.
 * Returns an array of question category objects generated by the AI.
 * @param {string} submission - The student's code submission.
 * @param {string} systemPrompt - The system prompt for generating question categories.
 * @param {number} maxAPIRetries - Maximum number of retries for the AI service.
 * @returns {Array<Object>} Array of question category objects.
 */
const questionCategoriesGeneration = async (
    submission,
    systemPrompt,
    maxAPIRetries
) => {
    let allGeneratedQuestionCategories = [];
    const userPromptText = userPrompt(submission);

    // Call the AI service. We assume it returns a ready-to-use array of objects.
    const questionCategoriesFromAI = await generateAIResponse(
        systemPrompt,
        userPromptText
    );

    let c = 0;
    while (!questionCategoriesFromAI && c < maxAPIRetries) {
        console.log(`generating question categories again. c = ${c}`);
        questionCategoriesFromAI = await generateAIResponse(
            systemPrompt,
            userPromptText
        );
        c++;
    }

    if (questionCategoriesFromAI && Array.isArray(questionCategoriesFromAI)) {
        questionCategoriesFromAI.forEach((q) => {
            allGeneratedQuestionCategories.push({
                ...q,
            });
        });
    }
    console.log(`\n--- Question Categories Successfully Generated.`);

    return allGeneratedQuestionCategories;
};

/**
 * Generates questions for a specific question category using a system prompt and student's submission.
 * Calls the AI service to generate questions, with retry logic for failures.
 * Returns an array of question objects, each enriched with submission and category details.
 * @param {string} submission - The student's code submission.
 * @param {string} systemPrompt - The system prompt for generating questions for a category.
 * @param {Object} questionCategory - The question category object returned by AI.
 * @param {number} maxAPIRetries - Maximum number of retries for the AI service.
 * @returns {Array<Object>} Array of generated question objects.
 */
const questionGenerationFromQuestionCategories = async (
    submission,
    systemPrompt,
    questionCategory,
    maxAPIRetries
) => {
    let generatedQuestions = []; // storing all the generatedQuestions (only one for now; can be used to generate more).
    try {
        const userPromptText = userPrompt(submission);

        // Call the AI service. We assume it returns a ready-to-use array of objects.
        let questionsFromAI = await generateAIResponse(
            systemPrompt,
            userPromptText,
        );

        // simple loop to try generation maxAPIRetries times incase of failure.
        let c = 0;
        while (!questionsFromAI && c < maxAPIRetries) {
            console.log(`generating questions again. c = ${c}`);
            questionsFromAI = await generateAIResponse(
                systemPrompt,
                userPromptText
            );
            c++;
        }

        // just making sure that questionsFromAI is populated & parsed into an array
        if (questionsFromAI && Array.isArray(questionsFromAI)) {
            questionsFromAI.forEach((q) => {
                generatedQuestions.push({
                    submission: submission.trim(), // Add the student's code
                    questionCategoryName: questionCategory.name,
                    questionCategoryDefinition: questionCategory.definition,
                    questionCategoryDirectives:
                        questionCategory.generation_directives,
                    ...q, // Spread the rest of the question fields(if any)
                });
            });
        }
    } catch (error) {
        console.error(
            `Failed to process submission:`,
            error.message
        );
        throw error;
    }

    return generatedQuestions;
};

/**
 * Creates a new exercise for a given user and assignment.
 * Finds the user and assignment, determines the author, and retrieves the submission.
 * Generates question categories and questions using AI, then constructs and returns the exercise object.
 * Throws an error if no valid author is found.
 * @param {string} userId - vuNetId of the user requesting the exercise.
 * @param {string} assignmentId - UUID of the assignment for which to create the exercise.
 * @returns {Object} The created exercise object, ready to be saved to the database.
 */
const generateExercise = async (userId, assignmentId) => {
    const user = await User.findOne({ vuNetId: userId }, { _id: 0 });
    const assignment = await Assignment.findOne(
        { uuid: assignmentId },
        { _id: 0 }
    );
    const author = await findAuthor(user, assignment);

    if (!author) {
        // No valid author found, cannot proceed
        throw new Error(
            `No valid author with a qualifying submission found for assignment ${assignment?.identifier || assignmentId}. Cannot generate exercise.`
        );
    }

    const submission = await getSubmission(
        author.email,
        assignment.identifier,
        author.studyParticipation
    );

    const questionCategories = await questionCategoriesGeneration(
        submission,
        systemPromptQuestionCategories(3, 6),
        3 // max retries
    );

    let questions = [];

    let numberOfQuestions = 5;
    const typesCount = questionCategories.length;
    const base = Math.floor(numberOfQuestions / typesCount);
    const remainder = numberOfQuestions % typesCount;

    for (let i = 0; i < typesCount; i++) {
        const qt = questionCategories[i];
        const count = i === typesCount - 1 ? base + remainder : base;

        if (count <= 0) continue;

        const systemPromptText = systemPromptSpecificQuestionCategory(
            qt,
            count
        );
        const userPromptText = await userPrompt(submission);
        let questionsForType = await questionGenerationFromQuestionCategories(
            systemPromptText,
            userPromptText,
            qt,
            3 // max retries
        );

        // Add additional fields to each question
        questionsForType = questionsForType.map((question) => ({
            ...question,
            _id: new mongoose.Types.ObjectId(),
            uuid: crypto.randomUUID(),
            difficulty: "easy",
            timeSpent: 0,
            status: "not-attempted",
            type: "multiple-choice",
        }));

        questions = questions.concat(questionsForType);
    }

    const exercise = new Exercise({
        _id: new ObjectId(),
        uuid: crypto.randomUUID(),
        userId,
        authorId: author.vuNetId,
        assignmentId,
        questions,
        status: "Not Started",
        totalTimeSpent: 0,
        totalCorrect: 0,
        completedQuestions: 0,
        submission,
        createdTimestamp: new Date(),
    });
    return exercise;
};

module.exports = { generateExercise };
